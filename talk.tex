\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{fancyvrb}

\title{Exploration Oriented Programmming Nitpicks}
\subtitle{REPL to Production}
\author{Moshe Zadka -- https://cobordism.com}
\date{North Bay Python 2018}
 
\begin{document}
 
\begin{titlepage}
\maketitle
\end{titlepage}

\frame{\titlepage}

Jupyter has brought back a new style of development:
what I like to call
"exploration-oriented programming".
Inside an interactive environment,
we intermix writing code
and running it,
in a persistent process --
with persistent memory,
persistent files and
everything else.
We modify our code as needed,
running it to
see what happens.

When I was a kid,
literally a six year old boy,
I simply called this
"programming".
I had no idea that for "proper"
programming,
you have to edit text files in an integrated development environment,
hit the "compile and debug" button,
set break points,
then trash the process,
modify the code and start again.

\begin{frame}[fragile]
\frametitle{LOGO}

\includegraphics[height=7cm,width=10cm]{logo.png}

\end{frame}


I had my LOGO environment,
where I would write a function,
then run it and see what it did to the screen.
Then I would edit it,
exit the internal editor,
and the screen still had whatever I draw on it earlier.
I would run the function again.

\begin{frame}
\frametitle{GW-Basic}

\includegraphics[height=7cm,width=10cm]{gwbasic.png}

\end{frame}

Then I grew up,
and I was a big kid,
seven years old.
I had my GW-Basic environment.
The program was a list of lines.
I could run it,
and it would run in a global namespace.
I could specify
"run starting at line 150",
so I could run only specific parts.
I could also execute lines of code directly.

If this was in graphical mode,
the graphics would be persisted between runs.

When I was eleven,
I was introduced to the magical world of Turbo C++.
You would write reams of code.
Then you would run "compile and run",
which inevitably crash.
Then you would run "compile and debug",
set a breakpoint,
then step carefully until you found out which variable was wrong.
Then you would exit all that careful local state,
hopeful that you knew what was wrong.
You edited the code.
You ran "compile and debug".
It would,
inevitably, crash.

I fell out of love with programming until,
in my 20s,
I met the Python repl.

\begin{frame}
\frametitle{Python REPL}

\includegraphics[height=7cm,width=10cm]{python-repl.png}

\end{frame}

It was not as cool as LOGO,
or as GW-Basic:
but at least it had the basics,
the ability to iterate through code.
Imagine my frustration when,
after getting a for loop wrong,
I had to up-arrow roughly one million times to
fix it.

Enter IPython:


\begin{frame}
\frametitle{IPython REPL}

\includegraphics[height=7cm,width=10cm]{ipython.png}

\end{frame}

Sadly,
inline persistent graphics
were a thing of the past.



\begin{frame}
\frametitle{Jupyter}

\includegraphics[height=7cm,width=10cm]{jupyter-notebook-page.png}

\end{frame}


\begin{frame}
\frametitle{What is Jupyter?}

\begin{itemize}
\item Web interface
\item Kernel
\item Persistent history
\item Other goodies!
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Kernel}

\begin{itemize}
\item Handles snippets
\item In-memory state
\item Semi-disposable
\item Tornado event loop
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Magic}

\begin{lstlisting}
%%pdb
\end{lstlisting}

\begin{lstlisting}
%% capture output
...
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Managing Kernels}

\begin{lstlisting}
def add_to(kernel_venv, jupyter_venv):
    python = os.path.join(kernel_venv, 'bin', 'python')
    name = os.path.basename(kernel_venv)
    subprocess.check_call([python, '-m',
                           'pip', 'install', 'ipykernel'])
    subprocess.check_call([python, '-m',
                           'ipykernel', 'install',
                           '--name', name,
                           '--display-name', name,
                           '--prefix', venv])
    jupyter = os.path.join(jupyter_venv, 'bin', 'jupyter')
    spec = os.path.join(venv, 'share/jupyter/kernels', name)
    subprocess.check_call([jupyter, 'kernelspec', 'install', spec])
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Security Model}

\begin{itemize}
\item Opaque security token
\item By default, listen only on localhost
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Notebooks}

\begin{itemize}
\item Editable history
\item Inputs and outputs
\item Code, not state
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Notebooks from the Inside}

\begin{lstlisting}
{
 "cells": [
  { "cell_type": "code",
   ...
    "source": ["1 + 1"]
  }
 ]
 "nbformat": 4,
 "nbformat_minor": 1
}
\end{lstlisting}

\end{frame}

7 minute mark

\begin{frame}
\frametitle{REPL History}
\end{frame}

\begin{frame}[fragile]
\frametitle{Global namespace}

\begin{lstlisting}[frame=single]
some_thing = 15
\end{lstlisting}

\begin{lstlisting}[frame=single]
some_thing * 2
\end{lstlisting}

\begin{lstlisting}[frame=single]
30
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Redefining functions}

\begin{lstlisting}[frame=single]
def foo(a):
    return 2 * a
\end{lstlisting}

\begin{lstlisting}[frame=single]
foo(10)
\end{lstlisting}

\begin{lstlisting}[frame=single]
20
\end{lstlisting}

\begin{lstlisting}[frame=single]
def foo(a):
    return 3 * a
\end{lstlisting}

\begin{lstlisting}[frame=single]
30
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Immutable data structures}

\begin{lstlisting}[frame=single]
from pyrsistent import v
a = v(1, 2, 3)
\end{lstlisting}

\begin{lstlisting}[frame=single]
def increase_head(stuff):
    return stuff.set(0, stuff[0] + 1)
increase_head(a)
\end{lstlisting}

\begin{lstlisting}[frame=single]
pvector([2, 2, 3])
\end{lstlisting}

\begin{lstlisting}[frame=single]
def increase_tail(stuff):
    return stuff.set(-1, stuff[-1] + 1)
increase_tail(a)
\end{lstlisting}

\begin{lstlisting}[frame=single]
pvector([1, 2, 4])
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Verification as testing}

\begin{lstlisting}[frame=single]
# test
x = [1, 2, 3]
y = increase_tail(x)
assert_that(y[2], is_(5))
\end{lstlisting}

\begin{lstlisting}[frame=single]
...
AssertionError: 
Expected: <5>
     but: was <4>
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Classes}

\begin{lstlisting}[frame=single]
@attr.s(frozen=True)
class Point:
     x = attr.ib()
     y = attr.ib()
\end{lstlisting}


\end{frame}

\begin{frame}[fragile]
\frametitle{Dispatching}

\begin{lstlisting}[frame=single]
@singledispatch
def abs(thing):
    raise NotImplementedError("Cannot absolute value", thing)
\end{lstlisting}

\begin{lstlisting}[frame=single]
@abs.register(Point)
def abs(pt):
    return (pt.x**2 + pt.y**2) ** 0.5
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Version control}

\begin{lstlisting}
   "execution_count": 1,
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Cleaning outputs}

\begin{lstlisting}
with open("something.ipynb") as fpin:
    data = fpin.read()
    parsed = json.loads(data)
    for cell in parsed["cells"]:
        del cell["output"]
        del cell["execution_count"]
with open("something_cleaned.ipynb") as fpout:
    fpout.write(json.dumps(parsed))
\end{lstlisting}

\end{frame}

\begin{frame}
\frametitle{Cleaning outputs}

\begin{itemize}
\item Pre-commit hook
\item Test in CI that re-cleaning gives same result
\item Code review the cleaned file
\end{itemize}

\end{frame}


\begin{frame}[fragile]

\frametitle{Lint}

\begin{lstlisting}
% jupyter nbconvert --to=python something.ipynb
% flake8 something.py
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Test}

\begin{lstlisting}
with open("something.ipynb") as fpin:
    notebook = json.loads(fpin.read())
with open("something.py", "w") as fpout:
    for cell in notebook["cells"]:
        if ("# pragma: interactive-only" in
            cell["source"]):
            continue
        fpout.write(f"\n{cell['source']}\n")
subprocess.check_output(["pytest", "something.py"])
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{Custom diff}

\begin{lstlisting}
# Suitable for use as "git difftool"
def to_lines(fname):
    with open(fname) as fpin:
        contents = json.loads(fpin.read())
    for i, cell in enumerate(contents["cells"]):
        yield f'Cell {i}'
        yield from cell["source"].splitlines()
sys.stdout.writelines(difflib.contextdiff(
    to_lines(os.environ['LOCAL']),
    to_lines(os.environ['REMOTE']),
    'a/' + os.environ['MERGED'],
    'b/' + os.environ['MERGED'],
))
\end{lstlisting}


\end{frame}

\begin{frame}
\frametitle{Custom merge}

\begin{itemize}
\item Clean
\item Merge
\item Add dummy output
\item (Beyond current scope)
\end{itemize}

\end{frame}


21 minute mark

\begin{frame}[fragile]
\frametitle{Importing Notebooks}

\begin{lstlisting}
@attr.s(frozen=True)
class NotebookLoader:
    contents = attr.ib()

    def create_module(self, spec):
        return importlib.util.module_from_spec(spec)

    def exec_module(self, module):
        for cell in json.loads(contents)["cells"]:
            if cell.starts_with("#pragma: module"):
               exec(cell, module.__dict__)
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Finding Notebooks}

\begin{lstlisting}
class NotebookFinder(object):
 
    def find_module(self, fullname, path=None):
        if path is None:
            return None
        name = fullname.split('.')[-1] + '.ipynb'
        if not resources.is_resource(path, name):
            return None
        return NotebookLoader(resources.read_text(path, name))

import sys
sys.meta_path.append(NotebookFinder())
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Integrating with packages}

\begin{lstlisting}
somepackage/
           __init__.py
             import sys
             sys.meta_path.append(NotebookFinder())
           module.ipynb
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{Producing documentation}

\begin{lstlisting}
.. automodule package.module
   :members:
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Producing documentation}

\begin{lstlisting}
with open("something.ipynb") as fpin:
    notebook = json.loads(fpin)
with open("something.md", "w") as mdout:
    for cell in notebook["cells"]:
        if cell["cell_type"] != "markdown":
            continue
        mdout.write(cell["source"])
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{Building wheels}

\begin{lstlisting}
MANIFEST.in
  include *.ipynb
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Exporting API}

\begin{lstlisting}[frame=single]
INTERACTIVE = False
\end{lstlisting}

\begin{lstlisting}[frame=single]
# pragma: interactive-only 
INTERACTIVE = True
\end{lstlisting}

\begin{lstlisting}[frame=single]
from publication import publish
__all__ = ['some_function',
           'SomeClass']
if not INTERACTIVE:
    publish()
\end{lstlisting}

\end{frame}

28 minute mark

\begin{frame}
\frametitle{Code as Successive Approximation}

Are we ever "done"?

\end{frame}

\begin{frame}
\frametitle{REPL as IDE}

\begin{itemize}
\item Still nascent...
\item ...getting better
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Our predecessors}

\begin{itemize}
\item Lisp
\item Smalltalk
\item Logo
\item GW-Basic
\end{itemize}

\end{frame}

\end{document}
